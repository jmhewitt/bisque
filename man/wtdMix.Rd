% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wtdMix.R
\name{wtdMix}
\alias{wtdMix}
\title{Develop a weighted mixture of posteriors}
\usage{
wtdMix(f1, f1.precompute = function(x, ...) {     x }, f2,
  w = "direct", w.init, w.link = NULL, w.linkparams = NULL,
  level = 2, w.control = NULL, ncores = 1, quadError = TRUE, ...)
}
\arguments{
\item{f1}{evaluates \eqn{f(\theta_1 | X, \theta_2)}.  \code{f1} must be able
to be called via \code{f1(theta1, params, log, ...)}.
\describe{
  \item{\code{theta1}}{a matrix of parameters at which to evaluate
    \eqn{f(\theta_1 | X, \theta_2)}. each row should be one set of values
    at which the density should be evaluated}
  \item{params}{a vector of parameters needed to evaluate
    \eqn{f(\theta_1 | X, \theta_2)}.  In most cases \code{params} will
    equal \eqn{theta_2}, but in some cases, \eqn{f(\theta_1 | X, \theta_2)}
    depends on functions of \eqn{\theta_2}, which can be pre-evaluated
    as the weighted mixture approximation is constructed.}
  \item{log}{TRUE to return \eqn{ln(f(\theta_1 | X, \theta_2))}}
  \item{...}{additional arguments needed for function evaluation}
}}

\item{f1.precompute}{function that pre-computes parameters for evaluating
\eqn{f(\theta_1 | X, \theta_2)}.  \code{f1.precompute} must be able to
be called via \code{f1.precompute(theta2, ...)} and return the argument
\code{params} for the function \code{f1}.}

\item{f2}{evaluates \eqn{f(theta_2 | X)}.  \code{f2} must be able to be
called via \code{f2(theta2, log, ...)}.}

\item{w}{Argument that specifies how the posterior mode of
\eqn{f(\theta_2| X)} should be evaluated.  The options for \code{w} are
described below.
\describe{
  \item{\code{'direct'}}{Instructs \code{wtdMix} to optimize \eqn{f2}
    directly, after applying link function transformations to the
    parameters \eqn{\theta_2}.}
  \item{\code{list()}}{Instructs \code{wtdMix} to determine the posterior
    mode of \eqn{f(\theta_2 | X)} using a function that is proportional,
    or otherwise a major component of \eqn{f(\theta_2 | X)}.  The list
    must specify the following arguments:
    \describe{
      \item{\code{f12}}{Function that is informative of
        \eqn{f(\theta_2 | X)} that will be optimized.  For example,
        \code{f12} may include components of \eqn{f(\theta_2 | X)}, or it
        may be proportional to the joint posterior distribution
        \eqn{f(\theta_1, \theta_2 | X)}.  \code{f12} must be able to be
        called via \code{f12(theta12, log, ...)}.}
      \item{\code{theta2.inds}}{After optimizing \code{f12}, \code{wtdMix}
        will use the hessian at the mode to develop a gaussian
        approximation to \code{f12}.  The argument \code{theta2.inds}
        specifies the indices of \code{theta12} that correspond to
        \eqn{\theta_2}.  \code{wtdMix} will integrate out the
        non-\eqn{\theta_2} indices from the Gaussian approximation to
        \code{f12}.}
      \item{\code{f1.init}}{It is assumed that
        \eqn{f(\theta_1|\theta_2, X)} is not known exactly if \code{f12}
        is used.  \code{wtdMix} will determine an integration constant for
        \eqn{f(\theta_1|\theta_2, X)} in this case by using numerical
        integration around the mode of the function.  \code{f1.init}
        specifies the initial guess for the mode.}
      \item{\code{f1.link}}{The integration of \code{f1} will be done on
        a transformed scale.  \code{f1.link} is a character vector that
        specifies the transformations to use.}
      \item{\code{f1.linkparams}}{Optional list of additional parameters
        for link functions.  For example, the logit function can be
        extended to allow mappings to any closed interval.  There should
        be one list entry for each link function.  Specify NA if no
        additional arguments are passed.}
       \item{\code{f1.control}}{Passes arguments to \code{optim} to
        determine the optimization scheme used.}
       \item{\code{f1.level}}{Determines the quality of the approximate
        integration.  Higher numbers are more accurate approximations.}
    }
   }
}}

\item{w.init}{initial guess for mode of \eqn{f(\theta_2 | X)}.  Default is
\code{'identity'} for all parameters.}

\item{w.link}{character vector that specifies transformations used during
optimization and integration of \eqn{f(\theta_2 | X)}.  While
\eqn{\theta_2} may be defined on arbitrary support, \code{wtdMix} performs
optimization and integration of \eqn{\theta_2} on an unconstrained support.
The \code{link} vector describes the transformations that must be applied
to each element of \eqn{\theta_2}.  Jacobian functions for the
transformations will automatically be added to the optimization and
integration routines. Currently supported link functions are \code{'log'},
\code{'logit'}, and \code{'identity'}.}

\item{w.linkparams}{Optional list of additional parameters for link
functions.  For example, the logit function can be extended to allow
mappings to any closed interval.   There should be one list entry for each
link function.  Specify NA if no additional arguments are passed.}

\item{level}{accuracy level (typically number of grid points for the
underlying 1D quadrature rule) [description from mvQuad::createNIGrid]}

\item{w.control}{Limited list of options to pass to optim.}

\item{ncores}{number of cores used to parallelize computation of parameters
for \eqn{f(\theta_1 | \theta_2, X)}.}

\item{quadError}{TRUE if integration nodes and weight should be computed for
the \code{level-1} integration grid, so that quadrature approximation
error can be estimated.}

\item{...}{Additional arguments to pass to \code{f1}, \code{f1.precompute},
\code{f12}, and \code{f2}.}
}
\value{
A list with class \code{wtdMix}, which contains the following items.
  \describe{
    \item{\code{f}}{Function for evaluating the posterior density
     \eqn{f(\theta_1|X)}.  \code{f} is callable  via
     \code{f(theta1, log, ...)}.}
    \item{\code{mix}}{A matrix containing the pre-computed parameters for
      evaluating the mixture components \eqn{f(\theta_1 | \theta_2, X)}.
      Each row of the matrix contains parameters for one of the \eqn{K}
      mixture components.}
    \item{\code{wts}}{Integration weights for each of the mixture components.
      Some of the weights may be negative.}
    \item{\code{expectation}}{List containing additional tools for computing
      posterior expectations of \eqn{f(\theta_2|X)}.  However, posterior
      expectations of \eqn{f(\theta_1|X)} can also be computed when
      expectations of \eqn{f(\theta_1|\theta_2, X)} are known.  The elements
      of \code{expectation} are
      \describe{
        \item{\code{Eh}}{Function to compute \eqn{E[h(\theta_2)|X]}.
          \code{Eh} is callable via \code{Eh(h, ...)}, where \code{h} is a
          function callable via \code{h(theta2, ...)} and \code{...} are
          additional arguments to the function.  The function \code{h} is
          evaluated at the quadrature nodes \eqn{\theta_2^{(j)}}.}
        \item{\code{Eh.precompute}}{Exactly the same idea as \code{Eh}, but
          the function \code{h} is evalauted at the quadrature nodes after
          being passed through the function \code{f1.precompute}.}
        \item{\code{grid}}{The sparse-quadrature integration grid used.
          Helpful for seeing the quadrature nodes \eqn{\theta_2^{(j)}}.}
        \item{\code{wts}}{The integration weights for approximating the
          expectation \eqn{E[h]}.  Note that these integration weights may
          differ from the main integration weights for evaluating the
          posterior density \eqn{f(\theta_1|X)}.}
      }}
  }
}
\description{
For a Bayesian model
\deqn{ X ~ f(X | \theta_1, \theta_2)}
\deqn{ (\theta_1, \theta_2) ~ f(\theta_1, \theta_2),}
the marginal  posterior \eqn{f(\theta_1 | X)} distribution can be
approximated via weighted mixtures via
\deqn{ f(\theta_1 | X) \approx \sum_{j=1}^K f(\theta_1 | X, \theta_2) w_j }
where \eqn{w_j} is based on \eqn{f(\theta_2^{(j)} | X)} and weights
\eqn{\tilde w_j}, where \eqn{\theta_2^{(j)}} and \eqn{\tilde w_j} are
nodes and weights for a sparse-grid quadrature integration scheme.
The quadrature rule is developed by finding the posterior mode of
\eqn{f(\theta_2|X)}, after transforming \eqn{\theta_2} to an unconstrained
support.  For best results, \eqn{\theta_2} should be a continuous random
variable, or be able to be approximated by one.
}
\examples{
# load data
data('furseals')
dat = furseals
rm(furseals)

# compute constants
r = sum(dat$m)
nC = nrow(dat)

# set basic initialization for parameters
init = list(alpha=rep(.5, nC), theta=rep(.5,2), N = r+1)


#
# weighted mixtures posterior for N
#

post.alpha_theta = function(theta2, log = TRUE, ...) {
  # Function proportional to f(alpha, theta1, theta2 | c, r) 
  
  alpha = theta2[1:nC]
  theta = theta2[-(1:nC)]
  
  res = - sum(theta)/1000 - r * log(1-prod(1-alpha))
  for(i in 1:nC) {
    res = res + dbeta(alpha[i], theta[1] + dat$c[i], theta[2] + r - dat$c[i], 
                      log = TRUE) - lbeta(theta[1], theta[2]) + 
      lbeta(theta[1] + dat$c[i], theta[2] + r - dat$c[i])
  }
  
  if(log) { res } else { exp(res) }
}


post.N.mixtures = function(N, params, log = TRUE) {
  # The mixture component of the weighted mixtures for f(N | c, r)
  dnbinom(x = N-r, size = r, prob = params, log = log)
}

mixparams.N = function(theta2) {
  # compute parameters for post.N.mixtures
  1 - prod(1 - theta2[1:nC])
}

# build a weighted mixture of posteriors
post.N = wtdMix(
  f1 = post.N.mixtures,
  f1.precompute = mixparams.N,
  f2 = post.alpha_theta,
  w.init = c(init$alpha, init$theta),
  w.link = c(rep('logit', nC), rep('log', 2))
)

# compute posterior mean
post.N$expectation$Eh.precompute(h = function(p) {((1-p)*r/p + r)}, 
                                 quadError = TRUE)
}
